# Problem 1

The algorithm takes a split and conquer approach. At first, it takes 0 as the lower bound and the target number plus one as the upper bound. At each iteration, it verifies if the floored average of the lower and upper bound is a valid square root of the target number. If it is, it returns this average. If not, it calls the procedure recursively with updated lower and upper bounds, leaving only half of the possibilities to be verified in the next execution. Given `n` as the initial amount of numbers between the lower and upper bound, the algorithm splits this amount in half at each iteration, which makes it run in `O(log n)` time. Knowing that this is a recursive algorithm calling itself with half the range of possibilities each time, we may have `log n` procedure calls in the stack, which leads us to `O(log n)` space complexity.